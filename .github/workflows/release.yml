name: Release LevelOS

on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      ref:
        description: 'Git ref to build (defaults to current branch)'
        required: false

env:
  BUILD_TYPE: Release

concurrency:
  group: release-${{ github.ref || github.event.inputs.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  build-and-release:
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.event.inputs.ref || github.ref }}

    - name: Install release toolchain
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential nasm gcc-multilib grub-pc-bin grub-common xorriso qemu-system-x86 ccache

    - name: Cache ccache
      uses: actions/cache@v4
      with:
        path: ~/.ccache
        key: release-ccache-${{ runner.os }}-${{ hashFiles('Makefile', 'src/**/*.c', 'include/**/*.h') }}
        restore-keys: |
          release-ccache-${{ runner.os }}-

    - name: Prime ccache
      run: |
        mkdir -p ~/.ccache
        ccache --zero-stats
        ccache --max-size=1G
      env:
        CCACHE_DIR: ~/.ccache
        
    - name: Get Version Information
      id: version
      run: |
        # Extract version from Makefile
        MAJOR=$(grep "VERSION_MAJOR = " Makefile | cut -d' ' -f3 | tr -d '\r\n' | tr -d ' ')
        MINOR=$(grep "VERSION_MINOR = " Makefile | cut -d' ' -f3 | tr -d '\r\n' | tr -d ' ')
        PATCH=$(grep "VERSION_PATCH = " Makefile | cut -d' ' -f3 | tr -d '\r\n' | tr -d ' ')
        VERSION="${MAJOR}.${MINOR}.${PATCH}"
        # Clean version string of any special characters
        VERSION=$(echo "$VERSION" | tr -d '\r\n\t ' | sed 's/[^0-9.]//g')
        
        # Get commit info
        COMMIT_SHORT=$(git rev-parse --short HEAD)
        COMMIT_DATE=$(git log -1 --format=%cd --date=short)
        
        # Set outputs
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "commit_short=${COMMIT_SHORT}" >> $GITHUB_OUTPUT
        echo "commit_date=${COMMIT_DATE}" >> $GITHUB_OUTPUT
        echo "release_name=LevelOS v${VERSION}" >> $GITHUB_OUTPUT
        echo "tag_name=v${VERSION}" >> $GITHUB_OUTPUT
        
        # Display version info
        echo "Building LevelOS v${VERSION} (${COMMIT_SHORT})"
        
    - name: Clean Previous Build
      run: |
        echo "Cleaning previous build artifacts..."
        make clean
        
    - name: Build LevelOS Kernel
      run: |
        echo "Building LevelOS kernel..."
        make all
        
        # Verify kernel was built
        if [ -f build/level-os-*.bin ]; then
          echo "✅ Kernel binary found: $(ls build/level-os-*.bin)"
        else
          echo "ERROR: Kernel binary not found!"
          echo "Build directory contents:"
          ls -la build/
          echo "Looking for pattern: build/level-os-*.bin"
          find build/ -name "*.bin" -type f || echo "No .bin files found"
          exit 1
        fi
        
        echo "Kernel build successful:"
        make debug-size
      env:
        CC: ccache gcc
        CCACHE_DIR: ~/.ccache
        
    - name: Build Bootable ISO
      run: |
        echo "Creating bootable ISO..."
        make iso
        
        # Verify ISO was created (non-blocking)
        if [ -f build/level-os-*.iso ]; then
          echo "✅ ISO file found: $(ls build/level-os-*.iso)"
          ISO_FILE=$(ls build/level-os-*.iso | head -1)
          ISO_SIZE=$(ls -lh "$ISO_FILE" | awk '{print $5}')
          echo "ISO created successfully: ${ISO_SIZE}"
        else
          echo "❌ ISO file not found"
          echo "Build directory contents:"
          ls -la build/
          exit 1
        fi
      env:
        CC: ccache gcc
        CCACHE_DIR: ~/.ccache

    - name: ccache statistics
      run: ccache --show-stats
      env:
        CCACHE_DIR: ~/.ccache
        
    - name: Run Tests
      run: |
        set -euo pipefail
        echo "Running LevelOS release test suite..."

        cat <<'EOF' >/tmp/string_tests.c
        #include <assert.h>
        #include "lib/string.h"

        int main(void) {
          char buf[8];
          memset(buf, 'A', sizeof(buf));
          assert(strlen("hello") == 5);
          assert(strlen("") == 0);
          memset(buf, 0, sizeof(buf));
          memcpy(buf, "abcd", 5);
          assert(memcmp(buf, "abcd", 5) == 0);
          buf[2] = 'z';
          assert(memcmp(buf, "abzd", 4) < 0);
          return 0;
        }
        EOF

        gcc -std=gnu11 -Wall -Wextra -fno-builtin -Iinclude -Isrc/lib src/lib/string.c /tmp/string_tests.c -o /tmp/string_tests
        /tmp/string_tests

        echo "Testing kernel boot in QEMU (headless)..."
        if command -v qemu-system-i386 >/dev/null 2>&1; then
          set +e
          timeout 30s qemu-system-i386 -kernel build/level-os-*.bin -nographic -serial stdio -display none >build/qemu-console.log 2>&1
          status=$?
          set -e
          if [ "$status" -eq 0 ]; then
            echo "✅ QEMU exited cleanly"
          elif [ "$status" -eq 124 ]; then
            echo "⚠️  QEMU timed out after 30 seconds (expected for non-interactive boot)"
          else
            echo "❌ QEMU boot test failed with status $status"
            cat build/qemu-console.log
            exit $status
          fi
        else
          echo "❌ QEMU not available after installation"
          exit 1
        fi

    - name: Upload QEMU console log
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: release-qemu-log-${{ steps.version.outputs.version }}
        path: build/qemu-console.log
        if-no-files-found: warn

    - name: Prepare Release Assets
      run: |
        # Create release directory
        mkdir -p release-assets
        
        # Copy kernel binary
        if ls build/level-os-*.bin 1> /dev/null 2>&1; then
          cp build/level-os-*.bin release-assets/
          echo "✅ Kernel binary copied"
        else
          echo "❌ Kernel binary not found!"
          exit 1
        fi
        
        # Copy ISO file
        if ls build/level-os-*.iso 1> /dev/null 2>&1; then
          cp build/level-os-*.iso release-assets/
          echo "✅ ISO file copied"
        else
          echo "❌ ISO file not found during asset preparation"
          exit 1
        fi
        
        # Create checksums
        cd release-assets
        sha256sum *.bin > checksums.txt
        if ls *.iso 1> /dev/null 2>&1; then
          sha256sum *.iso >> checksums.txt
        fi
        cd ..
        
        # Create build info
        cat > release-assets/build-info.txt << EOF
        LevelOS Build Information
        ========================
        Version: ${{ steps.version.outputs.version }}
        Commit: ${{ steps.version.outputs.commit_short }}
        Build Date: ${{ steps.version.outputs.commit_date }}
        Architecture: i686 (32-bit x86)
        
        Files:
        - level-os-${{ steps.version.outputs.version }}.bin: Kernel binary
        - level-os-${{ steps.version.outputs.version }}.iso: Bootable ISO image
        - checksums.txt: SHA256 checksums
        - build-info.txt: This file
        
        Usage:
        1. For QEMU testing: qemu-system-i386 -kernel level-os-${{ steps.version.outputs.version }}.bin
        2. For real hardware: Burn ISO to USB/CD and boot
        3. For development: See project documentation
        EOF
        
        # List release assets
        echo "Release assets prepared:"
        ls -la release-assets/
        
    - name: Generate Release Notes
      id: release_notes
      run: |
        # Get commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        if [ -n "$LAST_TAG" ]; then
          COMMITS=$(git log ${LAST_TAG}..HEAD --oneline --no-merges)
        else
          COMMITS=$(git log --oneline --no-merges -10)  # Last 10 commits for first release
        fi
        
        # Create release notes
        cat > release-notes.md << EOF
        # LevelOS ${{ steps.version.outputs.version }} Release Notes
        
        ## Build Information
        - **Version**: ${{ steps.version.outputs.version }}
        - **Commit**: ${{ steps.version.outputs.commit_short }}
        - **Build Date**: ${{ steps.version.outputs.commit_date }}
        - **Architecture**: i686 (32-bit x86)
        
        ## What's Included
        - **Kernel Binary**: \`level-os-${{ steps.version.outputs.version }}.bin\` - Ready for QEMU testing
        - **Bootable ISO**: \`level-os-${{ steps.version.outputs.version }}.iso\` - Ready for real hardware
        - **Checksums**: \`checksums.txt\` - SHA256 verification
        - **Build Info**: \`build-info.txt\` - Detailed build information
        
        ## Quick Start
        \`\`\`bash
        # Test in QEMU
        qemu-system-i386 -kernel level-os-${{ steps.version.outputs.version }}.bin
        
        # Or burn ISO to USB/CD for real hardware testing
        \`\`\`
        
        ## Changes in This Release
        EOF
        
        if [ -n "$COMMITS" ]; then
          echo "$COMMITS" | sed 's/^/- /' >> release-notes.md
        else
          echo "- Initial release of LevelOS" >> release-notes.md
        fi
        
        cat >> release-notes.md << EOF
        
        ## System Requirements
        - **For QEMU**: Any modern Linux/Windows/macOS system with QEMU
        - **For Real Hardware**: x86 compatible PC with VGA support
        - **Memory**: Minimum 16MB RAM
        - **Storage**: Bootable USB/CD drive
        
        ## Documentation
        - See project repository for complete documentation
        - API reference, architecture guide, and development instructions included
        
        ## Verification
        \`\`\`bash
        # Verify checksums
        sha256sum -c checksums.txt
        
        # Check multiboot compliance  
        grub-file --is-x86-multiboot level-os-${{ steps.version.outputs.version }}.bin
        \`\`\`
        EOF
        
        echo "Release notes generated:"
        cat release-notes.md
        
    - name: Check if Release Exists
      id: check_release
      run: |
        # Check if this version tag already exists
        if git tag -l | grep -q "^v${{ steps.version.outputs.version }}$"; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Tag v${{ steps.version.outputs.version }} already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Tag v${{ steps.version.outputs.version }} does not exist"
        fi
        
    - name: Create Git Tag
      if: steps.check_release.outputs.exists == 'false'
      run: |
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git tag -a v${{ steps.version.outputs.version }} -m "LevelOS v${{ steps.version.outputs.version }} - Automated Release"
        git push origin v${{ steps.version.outputs.version }}
        
    - name: Get Asset Filenames
      if: steps.check_release.outputs.exists == 'false'
      id: assets
      run: |
        # Get actual filenames for upload
        if ls release-assets/level-os-*.bin 1> /dev/null 2>&1; then
          KERNEL_PATH=$(ls release-assets/level-os-*.bin | head -1)
          KERNEL_FILE=$(basename "$KERNEL_PATH")
          echo "kernel_file=${KERNEL_FILE}" >> $GITHUB_OUTPUT
          echo "Kernel file: ${KERNEL_FILE}"
        else
          echo "❌ No kernel binary found in release assets!"
          exit 1
        fi
        
        # Check if ISO exists
        if ls release-assets/level-os-*.iso 1> /dev/null 2>&1; then
          ISO_PATH=$(ls release-assets/level-os-*.iso | head -1)
          ISO_FILE=$(basename "$ISO_PATH")
          echo "iso_file=${ISO_FILE}" >> $GITHUB_OUTPUT
          echo "has_iso=true" >> $GITHUB_OUTPUT
          echo "ISO file: ${ISO_FILE}"
        else
          echo "has_iso=false" >> $GITHUB_OUTPUT
          echo "No ISO file available"
        fi
        
    - name: Create GitHub Release
      if: steps.check_release.outputs.exists == 'false'
      uses: actions/create-release@v1
      id: create_release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.version.outputs.version }}
        release_name: ${{ steps.version.outputs.release_name }}
        body_path: release-notes.md
        draft: false
        prerelease: false
        
    - name: Upload Kernel Binary
      if: steps.check_release.outputs.exists == 'false'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./release-assets/${{ steps.assets.outputs.kernel_file }}
        asset_name: ${{ steps.assets.outputs.kernel_file }}
        asset_content_type: application/octet-stream
        
    - name: Upload Bootable ISO
      if: steps.check_release.outputs.exists == 'false' && steps.assets.outputs.has_iso == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./release-assets/${{ steps.assets.outputs.iso_file }}
        asset_name: ${{ steps.assets.outputs.iso_file }}
        asset_content_type: application/x-iso9660-image
        
    - name: Upload Checksums
      if: steps.check_release.outputs.exists == 'false'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./release-assets/checksums.txt
        asset_name: checksums.txt
        asset_content_type: text/plain
        
    - name: Upload Build Info
      if: steps.check_release.outputs.exists == 'false'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./release-assets/build-info.txt
        asset_name: build-info.txt
        asset_content_type: text/plain
        
    - name: Cleanup Build Artifacts  
      if: always()
      run: |
        echo "Cleaning up build artifacts..."
        make clean
        rm -rf release-assets/
        rm -f release-notes.md
        
    - name: Build Summary
      if: always()
      run: |
        echo "=========================="
        echo "LevelOS Build Summary"
        echo "=========================="
        echo "Version: ${{ steps.version.outputs.version }}"
        echo "Commit: ${{ steps.version.outputs.commit_short }}"
        echo "Status: ${{ job.status }}"
        
        if [ "${{ job.status }}" = "success" ]; then
          echo "Release created successfully!"
          echo "Download: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }}"
        else
          echo "Build failed - check logs for details"
        fi
